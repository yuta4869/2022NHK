%%BeginResource: procset Adobe_pattern_AI3 1.1 0
currentpacking true setpacking
userdict /Adobe_pattern_AI3 16 dict dup begin put
/initialize
{
/definepattern where
{
pop
}
{
Adobe_pattern_AI3 begin
Adobe_pattern_AI3
{
dup xcheck
{
bind
} if
pop pop
} forall
mark
cachestatus 7 1 roll pop pop pop pop exch pop exch
{
{
10000 add
dup 2 index gt
{
exit
} if
dup setcachelimit
} loop
} stopped
cleartomark
} ifelse
} def
/terminate
{
currentdict Adobe_pattern_AI3 eq
{
end
} if
} def
errordict
/nocurrentpoint
{
pop
stop
} put
errordict
/invalidaccess
{
pop
stop
} put
/patternencoding
256 array def
0 1 255
{
patternencoding exch ( ) 2 copy exch 0 exch put cvn put
} for
/definepattern
{
17 dict begin
/uniform exch def
/cache exch def
/key exch def
/procarray exch def
/mtx exch matrix invertmatrix def
/height exch def
/width exch def
/ctm matrix currentmatrix def
/ptm matrix def
/str 32 string def
/slice 9 dict def
slice /s 1 put
slice /q 256 procarray length div sqrt floor cvi put
slice /b 0 put
/FontBBox [0 0 0 0] def
/FontMatrix mtx matrix copy def
/Encoding patternencoding def
/FontType 3 def
/BuildChar
{
exch
begin
/setstrokeadjust where {pop true setstrokeadjust} if
slice begin
dup q dup mul mod s idiv /i exch def
dup q dup mul mod s mod /j exch def
q dup mul idiv procarray exch get
/xl j width s div mul def
/xg j 1 add width s div mul def
/yl i height s div mul def
/yg i 1 add height s div mul def
uniform
{
1 1
}
{
width 0 dtransform
dup mul exch dup mul add sqrt dup 1 add exch div
0 height dtransform
dup mul exch dup mul add sqrt dup 1 add exch div
} ifelse
width 0 cache
{
xl 4 index mul yl 4 index mul xg 6 index mul yg 6 index mul
setcachedevice
}
{
setcharwidth
} ifelse
gsave
scale
newpath
xl yl moveto
xg yl lineto
xg yg lineto
xl yg lineto
closepath
clip
newpath
end
end
exec
grestore
} def
key currentdict definefont
end
} def
/patterncachesize
{
gsave
newpath
0 0 moveto
width 0 lineto
width height lineto
0 height lineto
closepath
patternmatrix setmatrix
pathbbox
exch ceiling 4 -1 roll floor sub 3 1 roll
ceiling exch floor sub
mul 1 add
grestore
} def
/patterncachelimit
{
cachestatus 7 1 roll 6 npop 8 mul
} def
/patternpath
{
exch dup begin setfont
ctm setmatrix
concat
slice exch /b exch slice /q get dup mul mul put
FontMatrix concat
uniform
{
width 0 dtransform round width div exch round width div exch
0 height dtransform round height div exch height div exch
0 0 transform round exch round exch
ptm astore setmatrix
}
{
ptm currentmatrix pop
} ifelse
{currentpoint} stopped not
{
2 npop
pathbbox
true
4 index 3 index eq
4 index 3 index eq
and
{
pop false
{
{2 npop}
{3 npop true}
{7 npop true}
{pop true}
pathforall
} stopped
{
5 npop true
} if
} if
{
height div ceiling height mul 4 1 roll
width div ceiling width mul 4 1 roll
height div floor height mul 4 1 roll
width div floor width mul 4 1 roll
2 index sub height div ceiling cvi exch
3 index sub width div ceiling cvi exch
4 2 roll moveto
FontMatrix mtx invertmatrix
dup dup 4 get exch 5 get rmoveto
ptm ptm concatmatrix pop
slice /s
patterncachesize patterncachelimit div ceiling sqrt ceiling cvi
dup slice /q get gt
{
pop slice /q get
} if
put
0 1 slice /s get dup mul 1 sub
{
slice /b get add
gsave
0 1 str length 1 sub
{
str exch 2 index put
} for
pop
dup
{
gsave
ptm setmatrix
1 index str length idiv {str show} repeat
1 index str length mod str exch 0 exch getinterval show
grestore
0 height rmoveto
} repeat
grestore
} for
2 npop
}
{
4 npop
} ifelse
} if
end
} def
/patternclip
{
clip
} def
/patternstrokepath
{
strokepath
} def
/patternmatrix
matrix def
/patternfill
{
dup type /dicttype eq
{
Adobe_pattern_AI3 /patternmatrix get
} if
gsave
patternclip
Adobe_pattern_AI3 /patternpath get exec
grestore
newpath
} def
/patternstroke
{
dup type /dicttype eq
{
Adobe_pattern_AI3 /patternmatrix get
} if
gsave
patternstrokepath
true
{
{
{
newpath 
moveto
}
{
lineto
}
{
curveto
}
{
closepath
3 copy
Adobe_pattern_AI3 /patternfill get exec
} pathforall
3 npop
} stopped
{
5 npop
patternclip
Adobe_pattern_AI3 /patternfill get exec
} if
}
{
patternclip
Adobe_pattern_AI3 /patternfill get exec
} ifelse
grestore
newpath
} def
/patternashow
{
3 index type /dicttype eq
{
Adobe_pattern_AI3 /patternmatrix get 4 1 roll
} if
{
2 npop (0) exch
2 copy 0 exch put pop
gsave
false charpath currentpoint
6 index 6 index 6 index
Adobe_pattern_AI3 /patternfill get exec
grestore
newpath moveto
2 copy rmoveto
} exch cshow
5 npop
} def
/patternawidthshow
{
6 index type /dicttype eq
{
Adobe_pattern_AI3 /patternmatrix get 7 1 roll
} if
{
2 npop (0) exch
2 copy 0 exch put 
gsave
_sp eq {5 index 5 index rmoveto} if
false charpath currentpoint
9 index 9 index 9 index
Adobe_pattern_AI3 /patternfill get exec
grestore
newpath moveto
2 copy rmoveto
} exch cshow
8 npop
} def
/patternashowstroke
{
4 index type /dicttype eq
{
patternmatrix /patternmatrix get 5 1 roll
} if
4 1 roll
{
2 npop (0) exch
2 copy 0 exch put pop
gsave
false charpath
currentpoint
4 index setmatrix
7 index 7 index 7 index
Adobe_pattern_AI3 /patternstroke get exec
grestore
newpath moveto
2 copy rmoveto
} exch cshow
6 npop
} def
/patternawidthshowstroke
{
7 index type /dicttype eq
{
patternmatrix /patternmatrix get 8 1 roll
} if
7 1 roll
{
2 npop (0) exch
2 copy 0 exch put
gsave
_sp eq {5 index 5 index rmoveto} if
false charpath currentpoint
7 index setmatrix
10 index 10 index 10 index
Adobe_pattern_AI3 /patternstroke get exec
grestore
newpath moveto
2 copy rmoveto
} exch cshow
9 npop
} def
currentdict readonly pop end
setpacking
%%EndResource
